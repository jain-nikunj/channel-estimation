
# coding: utf-8

# In[140]:


import numpy as np
import math
from random import random
# import matplotlib.pyplot as plt
from numpy import sin, linspace, pi, cos
# from scipy import fft, arange


def init_params():
    '''All global parameters initialized here'''
    global runMode, numSamples, fileSourceBitsExpt1, fileSinkComplexExpt1
    
    runMode = 0 #0: before expt1, 1: before expt2, 2: after expt2
    numSamples = 200 # Length of bit sequeunce


    #For files
    fileDirectory = "./exptfiles"
    fileSourceBitsExpt1 = "fileSourceBitsExpt1" #Binary file used as (byte) file source for expt 1
    fileSinkComplexExpt1 = "fileSinkComplexExpt1" #Binary file containing (complex) file sink dump from expt 1



    fileSourceBitsExpt1  = fileDirectory + "/" + fileSourceBitsExpt1
    fileSinkComplexExpt1  = fileDirectory + "/" + fileSinkComplexExpt1


#Before expt 1
def get_bits_data():
    '''Returns bit array to be written to file to be used as file source for gnuradio expt1 '''
    bitsData = [1 if random() > 0.5 else 0 for sample in range(numSamples)]
    
    return bitsData

def write_bits_input():
    '''Writes the byte array to be used as (byte) file source for gnuradio expt 1 '''
    
    bitsData = get_bits_data()
    
    #Write to file here
    with open(fileSourceBitsExpt1, 'wb') as newFile:
      newFileByteArray = bytearray(bitsData)
      newFile.write(newFileByteArray)
      newFile.close()
    

#Before expt 2


def get_complex_data():
    '''Returns complex data (read from dump file generated by gnuradio expt1)'''
    complexData = []    
    
    return complexData

def get_complex_tones():
    '''Returns complex values corresponding to input sine tones '''
    complexTones = []
    
    return complexTones


def write_complex_input():
    '''Writes the byte array for tone + data into file to be used as (complex) file source for gnuradio for expt2 '''
    
    complexTones = get_complex_tones()
    complexData = get_complex_data()
    
    #Write to file here     
    pass


#After expt 2
def correlate(x, y): 
    '''Returns x.y/sqrt(x.x*y.y) '''
    if(len(x) is len(y)):
        num = np.sum(np.multiply(x,y))
        den = np.sqrt(np.sum(np.multiply(x,x))*np.sum(np.multiply(y,y)))
        if den is not 0:
            return num/den
        else:
            return 1
    else:
        raise ValueError("Length of x = " + str(len(x)) + " does not match length of  y = "  + str(len(y)))
        
def read_output():
    '''Reads the complex values from output file sink generated by gnuradio expt 2'''
    complexOutput = []
    
    
    return complexOutput

def get_lag_estimate():
    '''Returns best lag estimate based on coarse timing synchronization using tones'''
    complexOutput = read_output()
    lagEstimate = []
    
    return lagEstimate

def get_channel_estimate():
    '''Returns estimated channel based on matrix inversion and searching a range around lag estimates'''
    lagEstimate = get_lag_estimate()
    channelEstimate = []
    
    
    return channelEstimate

def run():
    '''Call functions depending on modes'''
    if runMode is 0: #Before expt 1
        print("Writing byte array bit input...")
        write_bits_input()
    elif runMode is 1: #Before expt 2
        print("Writing byte array complex input...")
        write_complex_input()
    elif runMode is 2: #After expt 2
        print("Getting channel estimate...")
        channelEstimate = get_channel_estimate()
        print("Channel Estimate: ")
        print(channelEstimate)
    else:
        raise ValueError('Unsupported runMode ' + str(runMode))
        
def main():
    init_params()
    run()
    print("Done!")   

if __name__ == "__main__":
    main()    

