import numpy as np
import math
from random import random
import matplotlib.pyplot as plt
from numpy import sin, linspace, pi, cos
from scipy import fft, arange


def init_params():
    '''All global parameters initialized here'''
    global runMode, numSamples, fileSourceBitsExpt1, fileSinkComplexExpt2,fileSinkComplexExpt1, fileSourceComplexExpt2
    
    runMode = 2 #0: before expt1, 1: before expt2, 2: after expt2
    numSamples = 2000 # Length of bit sequeunce


    #For files
    fileDirectory = "./exptfiles"
    fileSourceBitsExpt1 = "fileSourceBitsExpt1" #Binary file used as (byte) file source for expt 1
    fileSinkComplexExpt1 = "fileSinkComplexExpt1" #Binary file containing (complex) file sink dump from expt 1
    fileSinkComplexExpt2 = "fileSinkComplexExpt2" #Binary file containing (complex) file sink dump from expt 2

    fileSourceComplexExpt2 = "fileSourceComplexExpt2" #Binary file used as (complex) file source for expt 2


    fileSourceBitsExpt1  = fileDirectory + "/" + fileSourceBitsExpt1
    fileSinkComplexExpt1  = fileDirectory + "/" + fileSinkComplexExpt1
    fileSinkComplexExpt2  = fileDirectory + "/" + fileSinkComplexExpt2

    fileSourceComplexExpt2 = fileDirectory + "/" + fileSourceComplexExpt2

#Before expt 1
def get_bits_data():
    '''Returns bit array to be written to file to be used as file source for gnuradio expt1 '''
    bitsData = [1 if random() > 0.5 else 0 for sample in range(numSamples)]
    
    return bitsData

def write_bits_input():
    '''Writes the byte array to be used as (byte) file source for gnuradio expt 1 '''
    
    bitsData = get_bits_data()
    
    #Write to file here
    with open(fileSourceBitsExpt1, 'wb') as newFile:
      newFileByteArray = bytearray(bitsData)
      newFile.write(newFileByteArray)
      newFile.close()
    

#Before expt 2


def get_complex_data():
    '''Returns complex values corresponding to input read from file sink of expt 1 '''
     

    # floatsIn = np.fromfile(fileSourceComplexExpt2)
    # complexData = np.array([complex(floatsIn[2*i], floatsIn[2*i + 1]) for i in range(len(floatsIn) // 2)])
    

    complexData = np.fromfile(fileSinkComplexExpt1, dtype = 'complex64')
    
    # plt.plot(complexData.real)
    # plt.title('expt1 output')
    # plt.show()


    return complexData

def get_complex_tones():
    '''Returns complex values corresponding to input sine tones '''
    complexTones = []
    N = 1600 #length of channel
    f = 1.0/N
    x = np.array(range(2*N))*(2*pi*f)
    y = sin(x)  + 0


    complexTones = np.array(y, dtype = 'complex64')
    # complexTones = np.zeros((1,2*len(y)))
    # for i in range(len(y)):
    #     complexTones[0][2*i] = y[i]
    #     complexTones[0][2*i+1] = 0

    # print(complexTones)
    return complexTones


def write_complex_input():
    '''Writes the byte array for tone + data into file to be used as (complex) file source for gnuradio for expt2 '''
    
    complexTones = get_complex_tones()
    complexData = get_complex_data()

    complexInput = np.concatenate([complexTones,complexData] , axis = 1)
    plt.plot(complexInput.real)
    plt.show()
    #Write to file here  
    with open(fileSourceComplexExpt2, 'wb') as newFile:       
        # complexData.tofile(fileSourceComplexExpt2)
        # print(complexTones)
        complexInput.tofile(fileSourceComplexExpt2)

 

#After expt 2
def correlate(x, y): 
    '''Returns x.y/sqrt(x.x*y.y) '''
    if(len(x) is len(y)):
        num = np.sum(np.multiply(x,y))
        den = np.sqrt(np.sum(np.multiply(x,x))*np.sum(np.multiply(y,y)))
        if den is not 0:
            return num/den
        else:
            return 1
    else:
        raise ValueError("Length of x = " + str(len(x)) + " does not match length of  y = "  + str(len(y)))
        
def read_output():
    '''Reads the complex values from output file sink generated by gnuradio expt 2'''
    
    complexOutput = np.fromfile(fileSinkComplexExpt2, dtype = 'complex64')
    # print(complexOutput)
    plt.plot(complexOutput.real)
    plt.title('expt2')
    plt.show()
    return complexOutput

def get_lag_estimate():
    '''Returns best lag estimate based on coarse timing synchronization using tones'''
    complexOutput = read_output()
    lagEstimate = []
    
    return lagEstimate

def get_channel_estimate():
    '''Returns estimated channel based on matrix inversion and searching a range around lag estimates'''
    lagEstimate = get_lag_estimate()
    channelEstimate = []
    
    
    return channelEstimate

def run():
    '''Call functions depending on modes'''
    if runMode is 0: #Before expt 1
        print("Writing byte array bit input...")
        write_bits_input()
    elif runMode is 1: #Before expt 2
        print("Writing byte array complex input...")
        write_complex_input()
    elif runMode is 2: #After expt 2
        print("Getting channel estimate...")
        channelEstimate = get_channel_estimate()
        print("Channel Estimate: ")
        print(channelEstimate)
    else:
        raise ValueError('Unsupported runMode ' + str(runMode))
        
def main():
    init_params()
    run()
    print("Done!")   

if __name__ == "__main__":
    main() 