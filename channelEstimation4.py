from __future__ import print_function
"""Cell:Utility"""
import errno
import numpy as np
import os
from scipy import pi
from matplotlib import pyplot as plt

try:
  os.makedirs('./logs/images/')
except OSError as e:
  if e.errno != errno.EEXIST:
    raise

log_file = open('./logs/channel_estimation.log', 'w+')
file_source_complex_expt2  = "./../fileSourceComplexExpt2"
file_sink_complex_expt2  = "./../fileSinkComplexExpt2_6"
os.chdir('./logs/images/')

def np_concatenate(x_array):
    """Returns np array corresponding to the cocatenation of all the np arrays in x_array"""
    z = []
    for cur_array in x_array:
        for i in range(len(cur_array)):
            z.append(cur_array[i])   
    z = np.array(z)
    return z
    
    
def get_max_range(x, tolerance):
    """Returns the indices and values for all values >= tolerance*maximum"""
    max_indices = []
    max_values = [] 
    max_value = max(x)

    for k,elem in enumerate(x):
        if elem >= tolerance*max_value:
            max_values.append(elem)
            max_indices.append(k)

    return [max_indices, max_values] 


def complex_dot(x, y):
    """Returns dot product of x with conjugate of y (inner product of x and y)"""
    if len(x) != len(y):
        raise ValueError("Input vectors need to be of same size but size x is " + str(len(x)) + " while size y is " + str(len(y)))
    else:     
        dot_xy = sum(x[i]*np.conj(y[i]) for i in range(len(x)))
        return dot_xy


def complex_correlation(x, y):    
    """Returns complex correlation (between -1 and 1 of the vectors x,y)"""
    if len(x) != len(y):
        raise ValueError("Input vectors need to be of same size but size x is " + str(len(x)) + " while size y is " + str(len(y)))
    else:
        correlation_xy = complex_dot(x,y)/np.sqrt(complex_dot(x,x)*(complex_dot(y,y)))
        return (correlation_xy)

def correlate(x, y): 
    '''Returns x.y/sqrt(x.x*y.y) '''
    if(len(x) == len(y)):
        num = np.sum(np.multiply(x,y))
        den = np.sqrt(np.sum(np.multiply(x,x))*np.sum(np.multiply(y,y)))
        if den is not 0:
            return num/den
        else:
            return 1
    else:
        raise ValueError("Length of x = " + str(len(x)) + " does not match length of  y = "  + str(len(y)))  
        
def to_scale(x, scale =1):
    x = np.array(x)
    y = scale*x/max(abs(x))
    return y

"""Cell:Complex input"""
len_tone = 2000

data_to_tone_ratio  = 1
sampling_frequency = 500e3
input_multiply_constant = 0.25

tone_frequencies = [ sampling_frequency/100.0, sampling_frequency/200.0, sampling_frequency/300.0] 
len_data = len(tone_frequencies)*len_tone*data_to_tone_ratio
tone_margin = 0.1
correlation_dict = {}

def get_complex_data():
    '''Returns complex values corresponding to input read from file sink of expt 1 '''    
    complex_data = np.fromfile(file_source_complex_expt2, dtype = 'complex64')
#     print(len_data)
    complex_data = complex_data[len_tone*len(tone_frequencies):len_tone*len(tone_frequencies) +len_data]
    return complex_data

def get_complex_tones():
    """Returns complex values corresponding to input sine tones """
   
    y = []
    x = np.array(range(len_tone))
    for k,tone_frequency in enumerate(tone_frequencies):
        cur_start = k*len_tone     
        y_temp = np.array(np.exp(x*2.0j*pi*tone_frequency/sampling_frequency))
        correlation_dict[tone_frequency] = {}
        correlation_dict[tone_frequency]['start'] = cur_start + int(len_tone*tone_margin)
        correlation_dict[tone_frequency]['wave'] = y_temp[int(len_tone*tone_margin):int(len_tone*(1 - tone_margin))]
        for i in range(len(y_temp)):
            y.append(y_temp[i])

    complex_tones = np.array(y, dtype = 'complex64')   
    return complex_tones


def get_complex_input():
       
    complex_tones = get_complex_tones()
    complex_data = get_complex_data()
    complex_input = input_multiply_constant*np.concatenate([complex_tones,complex_data] , axis = 0)
    return complex_input

complex_input = get_complex_input()
plt.figure()
plt.plot(complex_input.real)
plt.plot(complex_input.imag)
plt.savefig("complex_input.png")
plt.close('all')
for key in correlation_dict:
    print(str(key) + ' ' + str(correlation_dict[key]['start']), file=log_file)


"""Cell:Complex output"""
def read_output():  
    """Reads the complex values from output file sink generated by gnuradio expt 2"""
    
    complex_output = np.fromfile(file_sink_complex_expt2, dtype = 'complex64').reshape(-1,1)  
    plt.figure()
    plt.plot(complex_output[11:18000].real)
    plt.plot(complex_output[11:18000].imag)
    plt.savefig('complex_output.png')
    plt.close('all')
    
    return complex_output
    
complex_output = read_output()

"""Cell:Output segmentation"""

"""
    Segments the output stream into [tones + data ] windows based on coarse lag estimates
    Returns a list of tuples [start, np.array(y)]
    start:the sample in output stream where the current window starts
    
"""

data_to_tone_ratio  = 1
len_data = len(tone_frequencies)*len_tone*data_to_tone_ratio
max_lag_end = len(tone_frequencies)*(len_tone*2) + len_data
min_lag_start = 0
max_tolerance_threshold = 0.99
lag_jump = 5
len_window = len(tone_frequencies)*(len_tone) + len_data #Since equal length of tones to data

def get_lag_estimate(complex_output):
    '''Returns best lag estimate based on coarse timing synchronization using tones'''
   
    lag_start = min_lag_start;
    lag_est_array = []
    for tone_frequency in tone_frequencies:
        start = correlation_dict[tone_frequency]['start']
        cur_x = correlation_dict[tone_frequency]['wave']
        print ('Correlating for wave starting at ' + str(start) + '...',  file=log_file)
     
        lag_end = min(max_lag_end, len(complex_output) - len(cur_x) )


        corr_array = []
        lag_array = []
        for lag in np.arange(lag_start, lag_end+1, lag_jump):
            cur_y = complex_output[lag:lag+len(cur_x), 0]

            cur_corr = correlate(abs(cur_x.real), abs(cur_y.real))
            corr_array.append(cur_corr)
            lag_array.append(lag)
            # print ('Lag: ' + str(lag) + ', Corr: ' + str(cur_corr),  file=log_file)

        [max_indices, max_range] = get_max_range(corr_array, tolerance=max_tolerance_threshold)
        
        cur_lag_array = []
        for index in max_indices:
            cur_lag_array.append(lag_array[index])

        print('---Max Lags',  file=log_file)
        print('---' + str(cur_lag_array),  file=log_file)
        print('---Max Values',  file=log_file)
        print('---'+ str(max_range),  file=log_file)

        # cur_est_lag = cur_lag_array[len(cur_lag_array)//2] - start 
        cur_est_lag = cur_lag_array[len(cur_lag_array)-1] - start 

        print('---Current Estimated Lag: ' + str(cur_est_lag), file=log_file)
        lag_est_array.append(cur_est_lag)
  
    lag_estimate = lag_est_array[len(lag_est_array)//2]
    print('Final estimated lag: ' + str(lag_estimate), file=log_file)
    
    return lag_estimate


def get_distorted_output_array(complex_output):
    coarse_lag_estimate = get_lag_estimate(complex_output)

    window_start = coarse_lag_estimate
    window_end = window_start + len_window
    max_windows = float('inf')
    cur_num_window = 0

    distorted_output_array = []

    while window_end < len(complex_output) and cur_num_window < max_windows:
        cur_y = complex_output[window_start:window_end]
        distorted_output_array.append([window_start, cur_y])   
        window_start += len_window
        window_end =  window_start + len_window
        cur_num_window += 1
    
    print("Total of " + str(len(distorted_output_array)) + " windows ", file=log_file)
    return distorted_output_array
    
distorted_output_array = get_distorted_output_array(complex_output)

"""Cell:Test output segmentation"""
for idx in range(len(distorted_output_array)):
    x = range(distorted_output_array[idx][0], distorted_output_array[idx][0] + len(distorted_output_array[idx][1]))
    plt.figure()
    plt.plot(x,distorted_output_array[idx][1].real)
    plt.plot(x,distorted_output_array[idx][1].imag)
    plt.title('Window: ' + str(idx))
    plt.savefig('Window: {}, distorted segmented output.png'.format(str(idx)))
    
    plt.figure()
    complex_vector = distorted_output_array[idx][1]
    plt.scatter(complex_vector[7000:9500].real, complex_vector[7000:9500].imag)
    plt.savefig('Window: {}, distorted scatter.png'.format(str(idx)))

    plt.close('all')
    

"""Cell:Correct carrier frequency offset"""

len_region = int(len_tone/3) #This controls how good carrier frequency offset is

def get_pure_tone_frequency(complex_vector, index, region):
    """Get frequency of the pure tone in a range of 'region', around 'index' in complex_vector"""
    
    tone_values = []
    for i in range(index - region//2, index + region//2):
        if i >= 0 and i < len(complex_vector):
            tone_values.append(complex_vector[i])
    
    predicted_freq_array = []
    for i in range(1,len(tone_values)):
        tone_ratio = tone_values[i]/tone_values[i-1]
        cur_predicted_freq = float(np.angle(tone_ratio)/(2*pi))
        predicted_freq_array.append(cur_predicted_freq)
    
#     print(predicted_freq_array)
    predicted_freq =  np.mean(predicted_freq_array)
    return predicted_freq

def get_carrier_frequency_offset(complex_vector, complex_input, region):
    """Returns the predicted carrier frequency offset"""   
    freq_diff_array = []
    for tone_frequency in tone_frequencies:
        input_freq = get_pure_tone_frequency(complex_input, index = int(correlation_dict[tone_frequency]['start'])+ len_tone//2, region = region)
        output_freq = get_pure_tone_frequency(complex_vector, index = int(correlation_dict[tone_frequency]['start']) + len_tone//2, region = region) 
        cur_freq_diff = output_freq - input_freq    
        freq_diff_array.append(cur_freq_diff)  
#         print(freq_diff_array)
    freq_diff = np.mean(freq_diff_array) 
    return freq_diff
    

def get_corrected_output_array(distorted_output_array):
    corrected_output_array = []
    for idx in range(len(distorted_output_array)):
        complex_vector = distorted_output_array[idx][1]
        freq_diff = get_carrier_frequency_offset(complex_vector, complex_input, region = len_region)

        #Generate the correcting wave
        x = np.arange(len(complex_vector))
        correcting_wave = np.exp(x*pi*(-2j)*freq_diff)

        corrected_y = [complex_vector[i]*correcting_wave[i] for i in range(len(correcting_wave))]
        corrected_y = np.array(corrected_y)

        corrected_output_array.append([freq_diff, corrected_y])
    
    return corrected_output_array


corrected_output_array = get_corrected_output_array(distorted_output_array)

"""Cell:Test carrier frequency offset correction"""

carrier_freq_offset_array = [sampling_frequency*corrected_output_array[i][0] for i in range(len(corrected_output_array))]
plt.plot(carrier_freq_offset_array)
plt.title('Carrier frequency offset vs window')
plt.savefig('Carrier frequency offset vs window.png')
plt.figure()
# Main loop
for idx in range(len(corrected_output_array)):
    complex_vector = corrected_output_array[idx][1]
    freq_diff = corrected_output_array[idx][0]
    print('Segment: ' + str(idx)+ ' Carrier frequency offset: ' + str(freq_diff*sampling_frequency) + 'Hz,  Predicted period: ' + str(1/abs(freq_diff)), file=log_file)
    absOutput = max(abs(complex_vector[len_tone*len(tone_frequencies):]))
    absInput =  max(abs(complex_input[len_tone*len(tone_frequencies):]))
    absRatio = absOutput/absInput;
    dbLoss = 20*np.log10(absRatio)
    
    print('Window: '+str(idx), file=log_file)
    stringToLog = 'absOutput :{}, absInput: {}, absRatio: {}, dbLoss: {}'.format(
      absOutput, absInput, absRatio, dbLoss)
    print(stringToLog, file=log_file)
                   
    
#     plt.plot(complex_vector.real/abs(max(complex_vector.real)))
#     plt.plot(correcting_wave.real/abs(max(correcting_wave.real)))   
#     plt.show()
    
# #     plt.plot(complex_vector.imag/abs(max(complex_vector.imag)))
# #     plt.plot(correcting_wave.imag/abs(max(correcting_wave.imag)))
# #     plt.show()
    

#     plt.show()
    
#     plt.plot(to_scale((complex_vector[3070:3170].real)))
#     plt.plot(to_scale((complex_vector[3070:3170].imag)))
    
#     plt.plot((np.angle(complex_vector[8070:8170])))
#     plt.plot(to_scale(abs(complex_input[8000:8100])))
    
    plt.figure()
    plt.plot(complex_vector.real)
    plt.plot(complex_vector.imag)
    plt.savefig('Window: {}, corrected output.png'.format(str(idx)))
    
    plt.figure()
    plt.scatter(complex_vector[7000:9500].real, complex_vector[7000:9500].imag)
    plt.savefig('Window: {}, corrected output scatter.png'.format(str(idx)))

    plt.close('all')

plt.close('all')

def middle_point():
    return len_tone * len(tone_frequencies)

len_pure_tones = middle_point()

"Cell: Channel Estimate"

def get_channel_estimate_with_numtaps(
    numTaps, complexInput, complexOutput, lagSearchWindow):
    #Scan a range around the lag
    channelArray = []
    errorArray = []
    lagArray = []
    numSamplesUsed = len(complexInput) - numTaps
    start = max(-len(complexInput) // 2 + (len(complexOutput) // 2) - lagSearchWindow//2, 0)
    for i in range(lagSearchWindow):
        yStart = i + start
        yEnd = yStart + numSamplesUsed

        
#         if yEnd < len(complexOutput):
#             curY = complexInput[xStart:xEnd]
#         else:
#             raise ValueError('Index out of bounds in complex Input,' + \
#               'StartIndex: ' + str(xStart) + ', EndIndex: ' + str(xEnd) + \
#               ' Length: ' + str(len(complexInput)))

        if yStart >= 0 and yEnd < len(complexOutput):
            curY = complexOutput[yStart:yEnd]
        else:
            raise ValueError('Index out of bounds in complex Output' + \
              ', StartIndex: ' + str(yStart) + ', EndIndex: ' + str(yEnd) + \
              ' Length: ' + str(len(complexOutput)))


        # plt.plot(range(len(curX)), curX.real, 'b', range(len(curY)), curY.real, 'r')
        # plt.show()

        curX = complexInput
        matrix = []
        for i in range(numSamplesUsed):
          matrix.append([])
          for j in range(numTaps):
            matrix[i].append(curX[i + numTaps - 1 - j])

        matrix = np.array(matrix)
        matrixpinv = np.linalg.pinv(matrix)


        curChannelEstimate = np.dot(matrixpinv, curY)
        # print('------Channel Estimate: ')
        # print(curChannelEstimate)

        curError = np.linalg.norm(np.dot(matrix,curChannelEstimate) - curY,2)**2
        # print('------Error:' + str(curError))

#         lagArray.append()
        errorArray.append(curError)
        channelArray.append(curChannelEstimate)

    [minIndices, minRange] = get_min_range(errorArray, maxErrorToleranceThreshold)

    # print(minRange)
    # print(minIndices)
    yError = min(minRange)
    lenFlatRegion = len(minRange)
    channel = channelArray[minIndices[0]]

    return [yError, lenFlatRegion, channel]

maxErrorToleranceThreshold = 0.99
minTaps, maxTaps = 1, 3

def get_min_range(x, tolerance):
    '''Returns the indices and values for all values <= maximum/tolerance'''
    minIndices = []
    minRange = []
    minVal = min(x)

    for k,elem in enumerate(x):
        if elem <= minVal/tolerance:
            minRange.append(elem)
            minIndices.append(k)

    return [minIndices, minRange]

def get_channel_estimate(complexInput, complexOutput):
    '''Returns estimated channel based on matrix inversion and searching a range around lag estimates'''

    channelEstimate = []
    tapArray = []
    errorArray = []
    lenFlatRegionArray = []
    channelArray = []
    for numTaps in range(minTaps,maxTaps+1):
        print ('Getting channel estimate assuming ' + str(numTaps) + ' taps...', file=log_file)

        [yError, lenFlatRegion, channel] = get_channel_estimate_with_numtaps(
          numTaps, complexInput, complexOutput, lagSearchWindow)
        print ('Error: ' + str(yError), file=log_file)
        print('Length of flat region: ' + str(lenFlatRegion), file=log_file)

        tapArray.append(numTaps)
        errorArray.append(yError)
        channelArray.append(channel)

        # plt.plot(tapArray, errorArray, 'r')
        # plt.title('Error vs numTaps')
        # plt.ylim((0, 1e1*noiseThreshold))
        # plt.savefig('Er')
        # plt.show()
        # plt.plot(tapArray, lenFlatRegionArray, 'b')
        # plt.title('Length of flat region vs numTaps')
        # plt.show()

        #Get minimum index so that length of flat region is 2
        minIndex = -1
        predictedTaps = -1

        errorChangeArray = [0]
        for i in range(1,len(tapArray)):
           errorChange = abs(errorArray[i]-errorArray[i-1])/errorArray[i-1]
           errorChangeArray.append(errorChange)
           #print(tapArray[i], i, errorArray[i], errorArray[i-1], errorChange)
           if errorChange <= 0.1 and abs(errorArray[i]) < noiseThreshold:
            minIndex = i - 1
            predictedTaps = tapArray[i-1]
            break
        # plt.plot(tapArray, errorChangeArray, 'r')
        # plt.title('Error change vs numTaps')
        # plt.show()
        channelEstimate = channelArray[minIndex]
        print("Error V/S Number of Taps:", file=log_file)
        print(str(errorArray), file=log_file)
#        print("Min Index: " + str(minIndex), file=log_file)
#        print("Predicted numTaps: " + str(predictedTaps, file=log_file)
        print("Channel Estimate:", file=log_file)
        print(str(channelEstimate), file=log_file)
        for i in range(len(channelEstimate)):
            power = abs(channelEstimate[i])[0]
            print('Power: {}'.format(str(power)), file=log_file)
            angle = np.angle(channelEstimate[i])[0] * 180 / pi
            print('Angle: {}'.format(str(angle)), file=log_file)
 
noiseThreshold = 1e-1
inputCenter = middle_point() + len_data // 2
lagSearchWindow = 1000
buffer = 2 * lagSearchWindow
numSamples = len_data // 2

for windowIdx in range(len(corrected_output_array)):
    print('-------------------------', file=log_file)
    print('Window: {}'.format(str(windowIdx)), file=log_file)
    get_channel_estimate(complex_input[inputCenter - numSamples//2: inputCenter + numSamples //2], corrected_output_array[windowIdx][1][inputCenter - numSamples//2 - buffer: inputCenter + numSamples //2 + buffer])

log_file.close()
